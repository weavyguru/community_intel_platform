<div class="space-y-6">
  <!-- Header -->
  <div class="flex justify-between items-center">
    <div>
      <h1 class="text-3xl font-bold text-gray-900">Tasks</h1>
      <p class="mt-2 text-gray-600">Actionable items from community intelligence</p>
    </div>
    <div class="flex gap-2">
      <sl-button id="bulkActionsBtn" variant="default">
        <sl-icon slot="prefix" name="check2-square"></sl-icon>
        Bulk Actions
      </sl-button>
      <sl-button id="createTaskBtn" variant="primary">
        <sl-icon slot="prefix" name="plus-circle"></sl-icon>
        Create Task
      </sl-button>
    </div>
  </div>

  <!-- Filters -->
  <div class="bg-white rounded-lg shadow p-4">
    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
      <sl-select id="statusFilter" placeholder="All Status" value="false">
        <sl-option value="">All Status</sl-option>
        <sl-option value="false">Open</sl-option>
        <sl-option value="true">Completed</sl-option>
        <sl-option value="skipped">Skipped</sl-option>
      </sl-select>

      <sl-select id="priorityFilter" placeholder="All Priorities" value="">
        <sl-option value="">All Priorities</sl-option>
        <sl-option value="high">High</sl-option>
        <sl-option value="medium">Medium</sl-option>
        <sl-option value="low">Low</sl-option>
      </sl-select>

      <sl-select id="delegationFilter" placeholder="All Tasks" value="">
        <sl-option value="">All Tasks</sl-option>
        <sl-option value="delegated">Delegated</sl-option>
        <sl-option value="not-delegated">Not Delegated</sl-option>
      </sl-select>

      <div id="userFilterOrRefresh">
        <sl-button id="refreshTasksBtn" variant="primary" class="w-full">
          <sl-icon slot="prefix" name="arrow-clockwise"></sl-icon>
          Refresh
        </sl-button>
      </div>
    </div>
  </div>

  <!-- Tasks List -->
  <div id="tasksList">
    <div class="text-center py-8">
      <sl-spinner></sl-spinner>
      <p class="mt-2 text-gray-500">Loading tasks...</p>
    </div>
  </div>

  <!-- Create/Edit Task Dialog -->
  <sl-dialog id="taskDialog" label="Create New Task" style="--width: 600px;">
    <form id="taskForm">
      <input type="hidden" name="taskId" id="taskId">
      <div class="space-y-4">
        <sl-input name="title" label="Title" required></sl-input>

        <sl-textarea name="snippet" label="Description / Snippet" rows="3" required></sl-textarea>

        <sl-input name="sourceUrl" label="Source URL" type="url" required></sl-input>

        <sl-select name="priority" label="Priority" value="medium">
          <sl-option value="low">Low</sl-option>
          <sl-option value="medium">Medium</sl-option>
          <sl-option value="high">High</sl-option>
        </sl-select>

        <sl-textarea name="reasoning" label="Why This Task Was Created (Optional)" rows="2" placeholder="Explain why this task is important..."></sl-textarea>

        <sl-textarea name="suggestedResponse" label="Suggested Response (Optional)" rows="3" placeholder="Draft a suggested response..."></sl-textarea>
      </div>

      <div slot="footer" class="flex gap-2 justify-end pt-4">
        <sl-button id="cancelTaskBtn" variant="default">Cancel</sl-button>
        <sl-button type="submit" variant="primary" id="submitTaskBtn">Create Task</sl-button>
      </div>
    </form>
  </sl-dialog>

  <!-- Delete Confirmation Dialog -->
  <sl-dialog id="deleteTaskDialog" label="Delete Task">
    <p>Are you sure you want to delete this task? This action cannot be undone.</p>
    <div slot="footer" class="flex gap-2 justify-end">
      <sl-button id="cancelDeleteBtn" variant="default">Cancel</sl-button>
      <sl-button id="confirmDeleteBtn" variant="danger">Delete</sl-button>
    </div>
  </sl-dialog>

  <!-- Skip Confirmation Dialog -->
  <sl-dialog id="skipTaskDialog" label="Skip Task">
    <div id="skipDialogContent">
      <p>Mark this as reviewed but not engaging? It will stay in the system to prevent regeneration.</p>
    </div>
    <sl-textarea id="skipReasonInput" placeholder="Optional: Why are we skipping this?" rows="2"></sl-textarea>
    <div slot="footer" class="flex gap-2 justify-end">
      <sl-button id="cancelSkipBtn" variant="default">Cancel</sl-button>
      <sl-button id="confirmSkipBtn" variant="warning">Skip Task</sl-button>
    </div>
  </sl-dialog>

  <!-- Floating Action Bar (for bulk actions) -->
  <div id="bulkActionBar" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; min-width: 400px;">
    <div class="bg-white rounded-lg shadow-2xl border-2 border-indigo-500 p-4">
      <div class="flex items-center justify-between gap-4">
        <div class="flex items-center gap-2">
          <sl-icon name="check2-square" class="text-indigo-600 text-xl"></sl-icon>
          <span class="font-semibold text-gray-900" id="selectionCount">0 tasks selected</span>
        </div>
        <div class="flex gap-2">
          <sl-button id="bulkSkipBtn" variant="warning" size="medium">
            <sl-icon slot="prefix" name="x-circle"></sl-icon>
            Skip Selected
          </sl-button>
          <sl-button id="bulkCancelBtn" variant="default" size="medium">
            Cancel
          </sl-button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  let currentTasks = [];
  let allUsers = [];
  let isBulkMode = false;
  let selectedTasks = new Set();

  // Socket.IO for real-time updates
  if (typeof io !== 'undefined') {
    const tasksSocket = io();

    tasksSocket.on('task:updated', (data) => {
      console.log('Task updated:', data);
      // Only reload if on "All Status" filter, otherwise let local update handle it
      const statusFilter = document.getElementById('statusFilter').value;
      if (statusFilter === '') {
        loadTasks();
      }
      updateTaskCountBadge();
    });

    tasksSocket.on('task:delegated', (data) => {
      console.log('Task delegated:', data);
      // Update delegation info without full reload
      const taskCard = document.getElementById(`task-${data.taskId}`);
      if (taskCard && data.delegatedTo) {
        const detailsDiv = taskCard.querySelector('.task-details');
        // Could add delegation info here, but for now just note it was delegated
      }
    });

    tasksSocket.on('task:created', (data) => {
      console.log('Task created:', data);
      // Reload tasks to show new one
      loadTasks();
      updateTaskCountBadge();
    });
  }

  async function loadUsers() {
    try {
      const response = await fetch('/api/users');
      const data = await response.json();
      if (data.success) {
        allUsers = data.users;

        // Create delegated user filter dynamically
        const delegatedUserFilter = document.createElement('sl-select');
        delegatedUserFilter.id = 'delegatedUserFilter';
        delegatedUserFilter.placeholder = 'All Users';
        delegatedUserFilter.value = '';

        const allOption = document.createElement('sl-option');
        allOption.value = '';
        allOption.textContent = 'All Users';
        delegatedUserFilter.appendChild(allOption);

        allUsers.forEach(user => {
          const option = document.createElement('sl-option');
          option.value = user._id;
          option.textContent = user.name;
          delegatedUserFilter.appendChild(option);
        });

        // Store it but don't add to DOM yet
        window.delegatedUserFilterElement = delegatedUserFilter;
      }
    } catch (error) {
      console.error('Error loading users:', error);
    }
  }

  async function loadTasks() {
    const status = document.getElementById('statusFilter').value;
    const priority = document.getElementById('priorityFilter').value;
    const delegation = document.getElementById('delegationFilter').value;
    const delegatedUserFilter = document.getElementById('delegatedUserFilter');
    const delegatedUserId = delegatedUserFilter ? delegatedUserFilter.value : '';

    const params = new URLSearchParams();
    if (status) params.append('completed', status);
    if (priority) params.append('priority', priority);

    const tasksList = document.getElementById('tasksList');
    tasksList.innerHTML = '<div class="text-center py-8"><sl-spinner></sl-spinner></div>';

    try {
      const response = await fetch(`/api/tasks?${params.toString()}`);
      const data = await response.json();

      if (data.success) {
        let filteredTasks = data.tasks;

        // Apply delegation filter client-side
        if (delegation === 'delegated') {
          filteredTasks = filteredTasks.filter(task => task.delegatedTo);

          // Apply user-specific filter if selected
          if (delegatedUserId) {
            filteredTasks = filteredTasks.filter(task => task.delegatedTo && task.delegatedTo._id === delegatedUserId);
          }
        } else if (delegation === 'not-delegated') {
          filteredTasks = filteredTasks.filter(task => !task.delegatedTo);
        }

        // Sort: delegated first, then by priority (high→medium→low), then by date (newest first)
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        filteredTasks.sort((a, b) => {
          // First, sort by delegation status (delegated first)
          const aDelegated = a.delegatedTo ? 0 : 1;
          const bDelegated = b.delegatedTo ? 0 : 1;
          if (aDelegated !== bDelegated) return aDelegated - bDelegated;

          // Then sort by priority
          const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
          if (priorityDiff !== 0) return priorityDiff;

          // Finally sort by creation date (newest first)
          return new Date(b.createdAt) - new Date(a.createdAt);
        });

        currentTasks = filteredTasks;
        renderTasks(filteredTasks);
        checkUrlParams();
      } else {
        tasksList.innerHTML = '<p class="text-red-600 text-center">Error loading tasks</p>';
      }
    } catch (error) {
      console.error('Error loading tasks:', error);
      tasksList.innerHTML = '<p class="text-red-600 text-center">Error loading tasks</p>';
    }
  }

  function setFiltersFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const delegation = urlParams.get('delegation');
    const completed = urlParams.get('completed');
    const delegatedUser = urlParams.get('delegatedUser');

    // Pre-select filters based on URL params
    if (delegation) {
      const delegationFilter = document.getElementById('delegationFilter');
      if (delegationFilter && delegation === 'delegated') {
        delegationFilter.value = 'delegated';

        // Show delegated user filter by swapping with refresh button
        if (window.delegatedUserFilterElement) {
          const container = document.getElementById('userFilterOrRefresh');
          container.innerHTML = '';
          container.appendChild(window.delegatedUserFilterElement);
          window.delegatedUserFilterElement.addEventListener('sl-change', loadTasks);

          // Set delegated user if specified
          if (delegatedUser) {
            window.delegatedUserFilterElement.value = delegatedUser;
          }
        }
      }
    }

    if (completed !== null) {
      const statusFilter = document.getElementById('statusFilter');
      if (statusFilter) {
        statusFilter.value = completed;
      }
    }
  }

  function checkUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const taskId = urlParams.get('taskId');
    const done = urlParams.get('done');

    if (taskId) {
      setTimeout(() => {
        const taskElement = document.getElementById(`task-${taskId}`);
        if (taskElement) {
          taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          taskElement.style.animation = 'highlight 2s ease-in-out';

          if (done === 'true') {
            toggleTaskComplete(taskId, true);
          }
        }
      }, 500);
    }
  }

  function formatPostDate(timestamp) {
    if (!timestamp) return null;

    const date = new Date(timestamp);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return 'Today';
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays}d ago`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)}w ago`;
    if (diffDays < 365) return `${Math.floor(diffDays / 30)}mo ago`;
    return `${Math.floor(diffDays / 365)}y ago`;
  }

  function renderTasks(tasks) {
    const tasksList = document.getElementById('tasksList');

    if (tasks.length === 0) {
      tasksList.innerHTML = '<div class="bg-white rounded-lg shadow p-8 text-center"><p class="text-gray-500">No tasks found</p></div>';
      return;
    }

    tasksList.innerHTML = tasks.map(task => {
      const snippetPreview = task.snippet.length > 100 ? task.snippet.substring(0, 100) + '...' : task.snippet;
      const postDate = formatPostDate(task.metadata?.timestamp);

      return `
      <div id="task-${task._id}" class="bg-white rounded-lg shadow p-4 mb-3 task-card" data-task-id="${task._id}" data-expanded="false">
        <div class="flex items-start gap-3">
          <sl-checkbox class="task-select-checkbox" data-select-task="${task._id}" style="display: none;"></sl-checkbox>
          <sl-checkbox ${task.isCompleted ? 'checked' : ''} data-task-checkbox="${task._id}"></sl-checkbox>

          <div class="flex-1 min-w-0">
            <!-- Collapsed Header -->
            <div class="task-header cursor-pointer" data-toggle-task="${task._id}">
              <div class="flex items-start justify-between gap-2">
                <div class="flex-1 min-w-0">
                  <h3 class="text-base font-semibold ${task.isCompleted ? 'line-through text-gray-500' : 'text-gray-900'} mb-1">${task.title}</h3>
                  <p class="task-snippet-preview text-sm text-gray-600">${snippetPreview}</p>
                  <div class="flex flex-wrap gap-2 mt-2">
                    <span class="inline-block px-2 py-1 text-xs rounded ${getPriorityClass(task.priority)}">
                      ${task.priority.toUpperCase()}
                    </span>
                    ${postDate ? `<span class="inline-block bg-gray-100 text-gray-700 text-xs px-2 py-1 rounded">📅 ${postDate}</span>` : ''}
                    ${task.isCompleted && task.completedBy ? `<span class="inline-block bg-green-100 text-green-800 text-xs px-2 py-1 rounded">✓ ${task.completedBy.name}</span>` : ''}
                    ${task.isSkipped && task.skippedBy ? `<span class="inline-block bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded">⊘ SKIPPED by ${task.skippedBy.name}</span>` : ''}
                    ${task.delegatedTo && !task.isCompleted && !task.isSkipped ? `<span class="inline-block bg-indigo-100 text-indigo-800 text-xs px-2 py-1 rounded">→ ${task.delegatedTo.name}</span>` : ''}
                  </div>
                </div>
                <sl-icon-button name="chevron-down" class="task-expand-icon" label="Expand task"></sl-icon-button>
              </div>
            </div>

            <!-- Expanded Details -->
            <div class="task-details" style="display: none;">
              <div class="mt-3 pt-3 border-t border-gray-200">
                <p class="text-sm text-gray-600 mb-3">${task.snippet}</p>

                <div class="flex flex-wrap gap-2 mb-3">
                  ${task.intent ? `<span class="inline-block bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">${task.intent}</span>` : ''}
                  ${task.foundByAgent ? `<span class="inline-block bg-green-100 text-green-800 text-xs px-2 py-1 rounded">AI Found</span>` : ''}
                </div>

                ${task.metadata?.author ? `<p class="text-xs text-gray-500 mb-1">Author: ${task.metadata.author}</p>` : ''}
                ${task.isCompleted && task.completedBy ? `<p class="text-xs text-gray-500 mb-1">Completed by ${task.completedBy.name} on ${new Date(task.completedAt).toLocaleDateString()}</p>` : ''}
                ${task.isSkipped && task.skippedBy ? `<p class="text-xs text-orange-600 mb-1">Skipped by ${task.skippedBy.name} on ${new Date(task.skippedAt).toLocaleDateString()}</p>` : ''}
                ${task.delegatedTo && !task.isSkipped ? `<p class="text-xs text-indigo-600 mb-1">Delegated to ${task.delegatedTo.name} on ${new Date(task.delegatedAt).toLocaleDateString()}</p>` : ''}

                ${task.skippedReason ? `
                  <div class="mt-3 bg-orange-50 border border-orange-200 rounded-lg p-3">
                    <div class="flex items-center gap-2 mb-2">
                      <sl-icon name="info-circle" class="text-orange-600"></sl-icon>
                      <span class="text-xs font-semibold text-orange-800">Why This Was Skipped</span>
                    </div>
                    <p class="text-sm text-gray-700">${task.skippedReason}</p>
                  </div>
                ` : ''}

                ${task.reasoning ? `
                  <div class="mt-3 bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <div class="flex items-center gap-2 mb-2">
                      <sl-icon name="lightbulb" class="text-blue-600"></sl-icon>
                      <span class="text-xs font-semibold text-blue-800">Why This Task Was Created</span>
                    </div>
                    <p class="text-sm text-gray-700">${task.reasoning}</p>
                  </div>
                ` : ''}

                ${task.suggestedResponse ? `
                  <div class="mt-3 bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                    <div class="flex items-center justify-between mb-2">
                      <div class="flex items-center gap-2">
                        <span class="text-xs font-semibold text-yellow-800">Suggested Response</span>
                        <sl-badge variant="neutral" size="small" pill id="version-badge-${task._id}">v${task.currentVersion || 1}</sl-badge>
                      </div>
                      <div class="flex items-center gap-1">
                        <sl-icon-button name="pencil" label="Edit response" data-edit-response="${task._id}"></sl-icon-button>
                        <sl-icon-button name="clipboard" label="Copy response" data-copy-response="${task._id}"></sl-icon-button>
                      </div>
                    </div>
                    <div id="response-view-${task._id}">
                      <p id="response-${task._id}" class="text-sm text-gray-700 whitespace-pre-wrap">${task.suggestedResponse}</p>
                    </div>
                    <div id="response-edit-${task._id}" style="display: none;">
                      <sl-textarea id="response-textarea-${task._id}" rows="4" resize="auto"></sl-textarea>
                      <div class="flex gap-2 mt-2">
                        <sl-button size="small" variant="primary" data-save-response="${task._id}">
                          <sl-icon slot="prefix" name="check"></sl-icon>
                          Save
                        </sl-button>
                        <sl-button size="small" variant="default" data-cancel-edit="${task._id}">
                          Cancel
                        </sl-button>
                      </div>
                    </div>
                  </div>
                ` : ''}

                <div class="flex items-center justify-between mt-3">
                  <div class="flex items-center gap-3">
                    <a href="${task.sourceUrl}" target="_blank" class="text-sm text-indigo-600 hover:text-indigo-700">
                      View Source →
                    </a>
                    ${!task.isCompleted && !task.isSkipped ? `
                      <sl-select id="delegate-${task._id}" placeholder="Delegate to..." size="small" style="width: 200px;" data-task-id="${task._id}" value="${task.delegatedTo?._id || ''}">
                        ${allUsers.map(user => `<sl-option value="${user._id}">${user.name}</sl-option>`).join('')}
                      </sl-select>
                    ` : ''}
                  </div>
                  <div class="flex gap-2">
                    ${!task.isSkipped ? `
                      <sl-button variant="default" size="small" data-edit-task="${task._id}">
                        <sl-icon slot="prefix" name="pencil"></sl-icon>
                        Edit
                      </sl-button>
                      <sl-button variant="warning" size="small" data-skip-task="${task._id}">
                        <sl-icon slot="prefix" name="x-circle"></sl-icon>
                        Skip
                      </sl-button>
                    ` : `
                      <sl-button variant="default" size="small" data-unskip-task="${task._id}">
                        <sl-icon slot="prefix" name="arrow-counterclockwise"></sl-icon>
                        Unskip
                      </sl-button>
                    `}
                    <sl-button variant="danger" size="small" data-delete-task="${task._id}">
                      <sl-icon slot="prefix" name="trash"></sl-icon>
                      Delete
                    </sl-button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `}).join('');

    // Attach event listeners
    setTimeout(() => {
      // Delegation dropdowns
      document.querySelectorAll('sl-select[data-task-id]').forEach(select => {
        select.addEventListener('sl-change', (e) => {
          const taskId = e.target.getAttribute('data-task-id');
          const userId = e.target.value;
          delegateTask(taskId, userId);
        });
      });

      // Task expand/collapse
      document.querySelectorAll('[data-toggle-task]').forEach(header => {
        header.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-toggle-task');
          toggleTaskExpand(taskId);
        });
      });

      // Copy response buttons
      document.querySelectorAll('[data-copy-response]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-copy-response');
          copyResponse(taskId);
        });
      });

      // Edit response buttons
      document.querySelectorAll('[data-edit-response]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-edit-response');
          toggleEditResponseMode(taskId, true);
        });
      });

      // Save response buttons
      document.querySelectorAll('[data-save-response]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-save-response');
          saveEditedResponse(taskId);
        });
      });

      // Cancel edit buttons
      document.querySelectorAll('[data-cancel-edit]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-cancel-edit');
          toggleEditResponseMode(taskId, false);
        });
      });

      // Task checkboxes
      document.querySelectorAll('[data-task-checkbox]').forEach(checkbox => {
        checkbox.addEventListener('sl-change', (e) => {
          const taskId = e.currentTarget.getAttribute('data-task-checkbox');
          const isChecked = e.target.checked;
          toggleTaskComplete(taskId, isChecked);
        });
      });

      // Selection checkboxes (for bulk actions)
      document.querySelectorAll('[data-select-task]').forEach(checkbox => {
        checkbox.addEventListener('sl-change', (e) => {
          const taskId = e.currentTarget.getAttribute('data-select-task');
          const isChecked = e.target.checked;
          toggleTaskSelection(taskId, isChecked);
        });
      });

      // Delete task buttons
      document.querySelectorAll('[data-delete-task]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-delete-task');
          deleteTask(taskId);
        });
      });

      // Edit task buttons
      document.querySelectorAll('[data-edit-task]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-edit-task');
          editTask(taskId);
        });
      });

      // Skip task buttons
      document.querySelectorAll('[data-skip-task]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-skip-task');
          skipTask(taskId);
        });
      });

      // Unskip task buttons
      document.querySelectorAll('[data-unskip-task]').forEach(button => {
        button.addEventListener('click', (e) => {
          const taskId = e.currentTarget.getAttribute('data-unskip-task');
          unskipTask(taskId);
        });
      });
    }, 100);
  }

  function getPriorityClass(priority) {
    switch(priority) {
      case 'high': return 'bg-red-100 text-red-800';
      case 'medium': return 'bg-yellow-100 text-yellow-800';
      case 'low': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  }

  async function toggleTaskComplete(taskId, completed) {
    try {
      const endpoint = completed ? `/api/tasks/${taskId}/complete` : `/api/tasks/${taskId}/reopen`;
      const response = await fetch(endpoint, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        // Update UI without reloading
        const taskCard = document.getElementById(`task-${taskId}`);
        const titleElement = taskCard.querySelector('h3');

        if (completed) {
          titleElement.classList.add('line-through', 'text-gray-500');
          titleElement.classList.remove('text-gray-900');
        } else {
          titleElement.classList.remove('line-through', 'text-gray-500');
          titleElement.classList.add('text-gray-900');
        }

        // Update task count badge
        updateTaskCountBadge();
      } else {
        console.error('Task update failed:', data);
        showToast(data.error || 'Error updating task', 'danger', 'exclamation-triangle');
        // Revert checkbox state
        const checkbox = document.querySelector(`[data-task-checkbox="${taskId}"]`);
        checkbox.checked = !completed;
      }
    } catch (error) {
      console.error('Error toggling task:', error);
      showToast('Error updating task: ' + error.message, 'danger', 'exclamation-triangle');
      // Revert checkbox state
      const checkbox = document.querySelector(`[data-task-checkbox="${taskId}"]`);
      checkbox.checked = !completed;
    }
  }

  async function delegateTask(taskId, userId) {
    if (!userId) return;

    try {
      const response = await fetch(`/api/tasks/${taskId}/delegate`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        showToast('Task delegated successfully! Email sent to the user.', 'success', 'check-circle');

        // Update UI without reloading
        const taskCard = document.getElementById(`task-${taskId}`);
        const detailsDiv = taskCard.querySelector('.task-details');
        const delegateDropdown = taskCard.querySelector(`#delegate-${taskId}`);

        // Remove delegation dropdown
        if (delegateDropdown && delegateDropdown.parentElement) {
          delegateDropdown.parentElement.remove();
        }

        // Add delegation info to details section
        const delegationInfo = document.createElement('p');
        delegationInfo.className = 'text-xs text-indigo-600 mb-1';
        delegationInfo.textContent = `Delegated to ${data.task.delegatedTo.name} on ${new Date(data.task.delegatedAt).toLocaleDateString()}`;

        // Insert after author info
        const authorInfo = detailsDiv.querySelector('p.text-xs.text-gray-500');
        if (authorInfo) {
          authorInfo.parentNode.insertBefore(delegationInfo, authorInfo.nextSibling);
        } else {
          detailsDiv.querySelector('div').insertBefore(delegationInfo, detailsDiv.querySelector('div').firstChild);
        }

        // Update task count badge
        updateTaskCountBadge();
      } else {
        console.error('Delegation failed:', data);
        showToast(data.error || 'Error delegating task', 'danger', 'exclamation-triangle');
      }
    } catch (error) {
      console.error('Error delegating task:', error);
      showToast('Error delegating task: ' + error.message, 'danger', 'exclamation-triangle');
    }
  }

  function toggleTaskExpand(taskId) {
    const taskCard = document.getElementById(`task-${taskId}`);
    const isExpanded = taskCard.getAttribute('data-expanded') === 'true';
    const detailsDiv = taskCard.querySelector('.task-details');
    const expandIcon = taskCard.querySelector('.task-expand-icon');

    if (isExpanded) {
      // Collapse
      detailsDiv.style.display = 'none';
      taskCard.setAttribute('data-expanded', 'false');
      expandIcon.name = 'chevron-down';
    } else {
      // Expand
      detailsDiv.style.display = 'block';
      taskCard.setAttribute('data-expanded', 'true');
      expandIcon.name = 'chevron-up';
    }
  }

  function copyResponse(taskId) {
    const responseText = document.getElementById(`response-${taskId}`).textContent;
    navigator.clipboard.writeText(responseText).then(() => {
      showToast('Response copied to clipboard!', 'success', 'clipboard-check');
    }).catch(err => {
      console.error('Error copying text:', err);
      showToast('Error copying to clipboard', 'danger', 'exclamation-triangle');
    });
  }

  function toggleEditResponseMode(taskId, isEdit) {
    const viewDiv = document.getElementById(`response-view-${taskId}`);
    const editDiv = document.getElementById(`response-edit-${taskId}`);

    if (isEdit) {
      // Populate textarea with current response text
      const currentText = document.getElementById(`response-${taskId}`).textContent;
      const textarea = document.getElementById(`response-textarea-${taskId}`);
      textarea.value = currentText;

      viewDiv.style.display = 'none';
      editDiv.style.display = 'block';

      // Focus the textarea
      setTimeout(() => textarea.focus(), 100);
    } else {
      viewDiv.style.display = 'block';
      editDiv.style.display = 'none';
    }
  }

  async function saveEditedResponse(taskId) {
    try {
      const textarea = document.getElementById(`response-textarea-${taskId}`);
      const newResponse = textarea.value;

      if (!newResponse.trim()) {
        showToast('Response cannot be empty', 'warning', 'exclamation-triangle');
        return;
      }

      // Optimistic update: Update DOM immediately
      const responseText = document.getElementById(`response-${taskId}`);
      const versionBadge = document.getElementById(`version-badge-${taskId}`);

      // Store old values for rollback if needed
      const oldResponse = responseText.textContent;
      const oldVersion = versionBadge.textContent;
      const currentVersion = parseInt(oldVersion.replace('v', ''));
      const newVersion = currentVersion + 1;

      // Update UI immediately
      responseText.textContent = newResponse;
      versionBadge.textContent = `v${newVersion}`;
      toggleEditResponseMode(taskId, false);
      showToast('Response updated successfully!', 'success', 'check-circle');

      // Save to backend in background
      const response = await fetch(`/api/tasks/${taskId}/response`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ suggestedResponse: newResponse })
      });

      const data = await response.json();

      if (!data.success) {
        // Rollback on error
        responseText.textContent = oldResponse;
        versionBadge.textContent = oldVersion;
        showToast('Error: ' + (data.error || 'Failed to save response'), 'danger', 'exclamation-triangle');
      }
    } catch (error) {
      console.error('Save response error:', error);
      showToast('Error saving response', 'danger', 'exclamation-triangle');
    }
  }

  let taskToDelete = null;
  let taskToSkip = null;

  function skipTask(taskId) {
    taskToSkip = taskId;
    document.getElementById('skipReasonInput').value = '';
    const dialog = document.getElementById('skipTaskDialog');
    const dialogContent = document.getElementById('skipDialogContent');

    // Reset dialog for single task
    dialog.label = 'Skip Task';
    dialogContent.innerHTML = '<p>Mark this as reviewed but not engaging? It will stay in the system to prevent regeneration.</p>';

    dialog.show();
  }

  async function confirmSkipTask() {
    if (!taskToSkip) return;

    const reason = document.getElementById('skipReasonInput').value.trim();
    const dialog = document.getElementById('skipTaskDialog');

    // Check if this is a bulk operation
    const isBulk = taskToSkip === 'BULK';

    // Close dialog immediately
    dialog.hide();

    if (isBulk) {
      // Bulk skip operation
      const taskIds = Array.from(selectedTasks);
      taskToSkip = null;

      if (taskIds.length === 0) return;

      // Optimistically remove from DOM
      taskIds.forEach(taskId => {
        const taskCard = document.getElementById(`task-${taskId}`);
        if (taskCard) {
          taskCard.style.opacity = '0.5';
          taskCard.style.transition = 'opacity 0.3s ease';
          setTimeout(() => taskCard.remove(), 300);
        }
      });

      try {
        const response = await fetch('/api/tasks/bulk/skip', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ taskIds, reason: reason || undefined })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
          showToast(`${data.skippedCount} task${data.skippedCount !== 1 ? 's' : ''} skipped successfully`, 'warning', 'x-circle');
          if (data.failedCount > 0) {
            showToast(`${data.failedCount} task${data.failedCount !== 1 ? 's' : ''} failed to skip`, 'danger', 'exclamation-triangle');
          }
          // Exit bulk mode
          toggleBulkMode(false);
        } else {
          showToast('Error skipping tasks', 'danger', 'exclamation-triangle');
          loadTasks();
        }
      } catch (error) {
        console.error('Error bulk skipping tasks:', error);
        showToast('Error skipping tasks: ' + error.message, 'danger', 'exclamation-triangle');
        loadTasks();
      }
    } else {
      // Single skip operation
      const taskId = taskToSkip;
      taskToSkip = null;

      // Optimistically remove from DOM
      const taskCard = document.getElementById(`task-${taskId}`);
      if (taskCard) {
        taskCard.style.opacity = '0.5';
        taskCard.style.transition = 'opacity 0.3s ease';
        setTimeout(() => {
          taskCard.remove();
        }, 300);
      }

      // Skip in backend (badge will update via socket event)
      try {
        const response = await fetch(`/api/tasks/${taskId}/skip`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason: reason || undefined })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
          showToast('Task skipped successfully', 'warning', 'x-circle');
        } else {
          console.error('Skip failed:', data);
          showToast(data.error || 'Error skipping task', 'danger', 'exclamation-triangle');
          // Reload tasks if backend skip failed
          loadTasks();
        }
      } catch (error) {
        console.error('Error skipping task:', error);
        showToast('Error skipping task: ' + error.message, 'danger', 'exclamation-triangle');
        // Reload tasks if there was an error
        loadTasks();
      }
    }
  }

  async function unskipTask(taskId) {
    try {
      const response = await fetch(`/api/tasks/${taskId}/unskip`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        showToast('Task unskipped successfully', 'success', 'check-circle');
        loadTasks();
      } else {
        console.error('Unskip failed:', data);
        showToast(data.error || 'Error unskipping task', 'danger', 'exclamation-triangle');
      }
    } catch (error) {
      console.error('Error unskipping task:', error);
      showToast('Error unskipping task: ' + error.message, 'danger', 'exclamation-triangle');
    }
  }

  function editTask(taskId) {
    const task = currentTasks.find(t => t._id === taskId);
    if (!task) return;

    const dialog = document.getElementById('taskDialog');
    const form = document.getElementById('taskForm');

    dialog.label = 'Edit Task';
    document.getElementById('submitTaskBtn').textContent = 'Update Task';
    document.getElementById('taskId').value = taskId;

    form.querySelector('[name="title"]').value = task.title;
    form.querySelector('[name="snippet"]').value = task.snippet;
    form.querySelector('[name="sourceUrl"]').value = task.sourceUrl;
    form.querySelector('[name="priority"]').value = task.priority;
    form.querySelector('[name="reasoning"]').value = task.reasoning || '';
    form.querySelector('[name="suggestedResponse"]').value = task.suggestedResponse || '';

    dialog.show();
  }

  async function deleteTask(taskId) {
    taskToDelete = taskId;
    const dialog = document.getElementById('deleteTaskDialog');
    dialog.show();
  }

  async function confirmDeleteTask() {
    if (!taskToDelete) return;

    const taskId = taskToDelete;
    const dialog = document.getElementById('deleteTaskDialog');

    // Close dialog immediately
    dialog.hide();
    taskToDelete = null;

    // Optimistically remove from DOM
    const taskCard = document.getElementById(`task-${taskId}`);
    if (taskCard) {
      taskCard.style.opacity = '0.5';
      taskCard.style.transition = 'opacity 0.3s ease';
      setTimeout(() => {
        taskCard.remove();
      }, 300);
    }

    // Delete from backend (badge will update via socket event)
    try {
      const response = await fetch(`/api/tasks/${taskId}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        showToast('Task deleted successfully', 'success', 'check-circle');
      } else {
        console.error('Delete failed:', data);
        showToast(data.error || 'Error deleting task', 'danger', 'exclamation-triangle');
        // Reload tasks if backend deletion failed
        loadTasks();
      }
    } catch (error) {
      console.error('Error deleting task:', error);
      showToast('Error deleting task: ' + error.message, 'danger', 'exclamation-triangle');
      // Reload tasks if there was an error
      loadTasks();
    }
  }

  // Event listeners for filters
  document.getElementById('statusFilter').addEventListener('sl-change', loadTasks);
  document.getElementById('priorityFilter').addEventListener('sl-change', loadTasks);

  document.getElementById('delegationFilter').addEventListener('sl-change', (e) => {
    const container = document.getElementById('userFilterOrRefresh');
    const refreshBtn = document.getElementById('refreshTasksBtn');

    if (e.target.value === 'delegated' && window.delegatedUserFilterElement) {
      // Replace refresh button with user filter
      container.innerHTML = '';
      container.appendChild(window.delegatedUserFilterElement);

      // Add event listener to the filter
      window.delegatedUserFilterElement.addEventListener('sl-change', loadTasks);
    } else {
      // Restore refresh button
      container.innerHTML = '';
      container.appendChild(refreshBtn);

      // Reset user filter value if it exists
      if (window.delegatedUserFilterElement) {
        window.delegatedUserFilterElement.value = '';
      }
    }

    loadTasks();
  });

  // Create task button event listener
  document.getElementById('createTaskBtn').addEventListener('click', () => {
    const dialog = document.getElementById('taskDialog');
    const form = document.getElementById('taskForm');
    dialog.label = 'Create New Task';
    document.getElementById('submitTaskBtn').textContent = 'Create Task';
    document.getElementById('taskId').value = '';
    form.reset();
    dialog.show();
  });

  // Cancel button event listener
  document.getElementById('cancelTaskBtn').addEventListener('click', () => {
    const dialog = document.getElementById('taskDialog');
    dialog.hide();
    document.getElementById('taskForm').reset();
  });

  // Refresh button event listener
  document.getElementById('refreshTasksBtn').addEventListener('click', loadTasks);

  // Delete dialog event listeners
  document.getElementById('confirmDeleteBtn').addEventListener('click', confirmDeleteTask);
  document.getElementById('cancelDeleteBtn').addEventListener('click', () => {
    taskToDelete = null;
    document.getElementById('deleteTaskDialog').hide();
  });

  // Skip dialog event listeners
  document.getElementById('confirmSkipBtn').addEventListener('click', confirmSkipTask);
  document.getElementById('cancelSkipBtn').addEventListener('click', () => {
    taskToSkip = null;
    document.getElementById('skipTaskDialog').hide();
  });

  // Bulk Actions event listeners
  document.getElementById('bulkActionsBtn').addEventListener('click', toggleBulkMode);
  document.getElementById('bulkCancelBtn').addEventListener('click', () => toggleBulkMode(false));
  document.getElementById('bulkSkipBtn').addEventListener('click', bulkSkipSelected);

  // Bulk mode functions
  function toggleBulkMode(enable) {
    if (typeof enable === 'boolean') {
      isBulkMode = enable;
    } else {
      isBulkMode = !isBulkMode;
    }

    const bulkActionsBtn = document.getElementById('bulkActionsBtn');
    const bulkActionBar = document.getElementById('bulkActionBar');
    const selectCheckboxes = document.querySelectorAll('.task-select-checkbox');
    const completeCheckboxes = document.querySelectorAll('[data-task-checkbox]');

    if (isBulkMode) {
      // Enter bulk mode
      bulkActionsBtn.variant = 'primary';
      bulkActionBar.style.display = 'block';
      selectCheckboxes.forEach(cb => cb.style.display = 'block');
      completeCheckboxes.forEach(cb => cb.style.display = 'none');
      selectedTasks.clear();
      updateSelectionCount();
    } else {
      // Exit bulk mode
      bulkActionsBtn.variant = 'default';
      bulkActionBar.style.display = 'none';
      selectCheckboxes.forEach(cb => {
        cb.style.display = 'none';
        cb.checked = false;
      });
      completeCheckboxes.forEach(cb => cb.style.display = 'block');
      selectedTasks.clear();
      // Remove selection highlights
      document.querySelectorAll('.task-card').forEach(card => {
        card.style.backgroundColor = '';
      });
    }
  }

  function updateSelectionCount() {
    const count = selectedTasks.size;
    const countEl = document.getElementById('selectionCount');
    countEl.textContent = `${count} task${count !== 1 ? 's' : ''} selected`;

    // Enable/disable bulk skip button
    const bulkSkipBtn = document.getElementById('bulkSkipBtn');
    bulkSkipBtn.disabled = count === 0;
  }

  function toggleTaskSelection(taskId, checked) {
    if (checked) {
      selectedTasks.add(taskId);
      // Highlight selected task
      const taskCard = document.getElementById(`task-${taskId}`);
      if (taskCard) {
        taskCard.style.backgroundColor = '#EEF2FF'; // indigo-50
      }
    } else {
      selectedTasks.delete(taskId);
      // Remove highlight
      const taskCard = document.getElementById(`task-${taskId}`);
      if (taskCard) {
        taskCard.style.backgroundColor = '';
      }
    }
    updateSelectionCount();
  }

  async function bulkSkipSelected() {
    if (selectedTasks.size === 0) return;

    const taskIds = Array.from(selectedTasks);
    const taskTitles = taskIds.map(id => {
      const task = currentTasks.find(t => t._id === id);
      return task ? task.title : 'Unknown';
    });

    // Update dialog for bulk operation
    const dialog = document.getElementById('skipTaskDialog');
    const dialogContent = document.getElementById('skipDialogContent');
    dialog.label = `Skip ${taskIds.length} Task${taskIds.length !== 1 ? 's' : ''}`;

    dialogContent.innerHTML = `
      <p>Mark these as reviewed but not engaging? They will stay in the system to prevent regeneration.</p>
      <div class="mt-3 bg-gray-50 rounded p-3 max-h-40 overflow-y-auto">
        <p class="text-sm font-semibold text-gray-700 mb-2">Selected tasks:</p>
        <ul class="text-sm text-gray-600 list-disc list-inside">
          ${taskTitles.map(title => `<li>${title}</li>`).join('')}
        </ul>
      </div>
    `;

    document.getElementById('skipReasonInput').value = '';
    dialog.show();

    // Override confirmSkipTask for bulk operation
    taskToSkip = 'BULK';
  }

  // Handle task form submission (create or update)
  document.getElementById('taskForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const formData = new FormData(e.target);
    const taskId = formData.get('taskId');
    const taskData = {
      title: formData.get('title'),
      snippet: formData.get('snippet'),
      sourceUrl: formData.get('sourceUrl'),
      priority: formData.get('priority'),
      reasoning: formData.get('reasoning') || undefined,
      suggestedResponse: formData.get('suggestedResponse') || undefined
    };

    try {
      const isEdit = taskId && taskId.trim() !== '';
      const url = isEdit ? `/api/tasks/${taskId}` : '/api/tasks';
      const method = isEdit ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(taskData)
      });

      const data = await response.json();

      if (data.success) {
        showToast(isEdit ? 'Task updated successfully!' : 'Task created successfully!', 'success', 'check-circle');
        const dialog = document.getElementById('taskDialog');
        dialog.hide();
        document.getElementById('taskForm').reset();
        loadTasks();
      } else {
        showToast(data.error || `Error ${isEdit ? 'updating' : 'creating'} task`, 'danger', 'exclamation-triangle');
      }
    } catch (error) {
      console.error('Error submitting task:', error);
      showToast('Error submitting task: ' + error.message, 'danger', 'exclamation-triangle');
    }
  });

  // Load users and tasks on page load
  setFiltersFromUrl();
  loadUsers().then(() => loadTasks());
</script>

<style>
  @keyframes highlight {
    0%, 100% { background-color: white; }
    50% { background-color: #FEF3C7; }
  }
  .task-card {
    transition: all 0.3s ease;
  }
</style>
